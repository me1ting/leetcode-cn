package count_substrings_that_can_be_rearranged_to_contain_a_string_i

import "testing"

// https://leetcode.cn/problems/count-substrings-that-can-be-rearranged-to-contain-a-string-i/solutions/3037271/tong-ji-zhong-xin-pai-lie-hou-bao-han-li-2kiv/
// 这不是一个直观就能得出答案的题，而是需要技巧，参考方法2。
//
// 以测试用例`{"abcabc", "abc", 10}`为例，一个很朴素的想法：
// 从word1[0]开始，`abc`是合法的子字符串，那么`abca`,`abcab`,`abcabc`都是合法的子字符串，结果+4
// 从word1[1]开始，`bca`是合法的子字符串，那么同理，`bcab`,`bcabc`都是合法的子字符串，结果+3
// 从word1[2]开始，...，结果+2
// 从word1[3]开始，...，结果+1
// 最终结果为 4+3+2+1=10
//
// 因此可以使用一个滑动窗口[l,r]，当[l,r]满足要求时，结果+(len(word1)-r)
// 然后移动l+1，此时需要判断是否满足需求，如果不满足需要移动r，直到满足需求或到达word1末尾
func validSubstringCount(word1 string, word2 string) int64 {
	if len(word1) < len(word2) {
		return 0
	}

	diff := [26]int{} // 记录当前窗口每个字母的数量差值
	for _, c := range word2 {
		diff[c-'a']--
	}
	cnt := 0 // 记录不满足要求的字母的数量
	for _, n := range diff {
		if n < 0 {
			cnt++
		}
	}

	update := func(idx int, n int) {
		diff[idx] += n
		if n == -1 && diff[idx] == -1 {
			cnt++
		} else if n == 1 && diff[idx] == 0 {
			cnt--
		}
	}

	l, r := 0, 0 //[l,r)，初始时l,r相同，表示不包含word1[0]

	var res int64 = 0
	for l < len(word1) {
		for cnt > 0 && r < len(word1) {
			update(int(word1[r]-'a'), 1)
			r++
		}

		if cnt > 0 {
			break
		}

		for cnt == 0 {
			res += int64(len(word1) - r + 1)
			update(int(word1[l]-'a'), -1)
			l++
		}
	}

	return res
}

// Test function generated by copilot
func TestValidSubstringCount(t *testing.T) {
	tests := []struct {
		word1 string
		word2 string
		want  int64
	}{
		{"abc", "cba", 1},
		{"abc", "def", 0},
		{"aabbcc", "abc", 4},
		{"abcabc", "abc", 10},
	}

	for _, tt := range tests {
		t.Run(tt.word1+"_"+tt.word2, func(t *testing.T) {
			if got := validSubstringCount(tt.word1, tt.word2); got != tt.want {
				t.Errorf("validSubstringCount(%v, %v) = %v, want %v", tt.word1, tt.word2, got, tt.want)
			}
		})
	}
}
